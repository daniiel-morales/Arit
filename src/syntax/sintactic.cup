package syntax;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import ast.*;
import ast.NodoAST.*;

parser code
{:  
	public ArrayList<String> lista_errores=new ArrayList<String>();
	public NodoAST root;
    public String dir;
	
    //** Metodo al que se llama automaticamente ante algun error sintactico.*/
    public void syntax_error(Symbol s)
    {     
        System.out.println("RECUPERADO>>"+s.right+", "+s.left);  
        //lista_errores.add(s.value.toString()+", "+s.right+", "+s.left+", Error Sintactico Recuperado, Lexema Invalido, ");
    }

    /**Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores.*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {   
        System.out.println("PANICO>>"+s.right+", "+s.left);
        //lista_errores.add(s.value.toString()+", "+s.right+", "+s.left+", Error Sintactico, Lexema Invalido");
    }
:}

action code
{:
	public NodoAST transferirHijos(NodoAST e,NodoAST RESULT){
    	int x=0;
    	if(RESULT==null)
    		RESULT=new Instruccion();
    	if(e!=null)while(e.getChild(x)!=null){
			RESULT.add(e.getChild(x));	
			x++;
		}
		return RESULT;
    }
:}  


/* symbols */
terminal QUESTION, ASSIGN, COMA, COLON, SCOLON, OPAR, CPAR, OBRA, CBRA, OCUR, CCUR;

    /** arithmetic **/
terminal ADD, SUB, MUL, DIV, POT, MOD, INC_OP, DEC_OP;

    /** relational **/
terminal GTHAN, LTHAN, EQ_OP, NE_OP, GE_OP, LE_OP,AND_OP,OR_OP,INVERT;

/* literals */
terminal String  NUM, IDENTIFIER, TSTRING, TRUE_VAL, FALSE_VAL, NULL_VAL;

/* reserved words */

    /** statement **/

terminal CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR, CONTINUE, BREAK, RETURN;

terminal PRINT;//, S_LENGTH, TO_UP, TO_LOW, MATRIX, MEDIAN, TYPEOF, LENGTH, REMOVE, TRUNK;

terminal FUNCTION, IN;//ROUND, ARRAY, N_COL, N_ROW, MODE, MEAN, LIST, PLOT, C;

    /** GUI **/

//terminal PIE, BAR_PLOT, HIST;

non terminal NodoAST statement_list, statement, type_specifier; 
non terminal NodoAST expression, primary_expression, ternary_expression, bool_expression;
non terminal NodoAST id_or_call, return_statement, jump_statement, iteration_statement, labeled_statement;
non terminal NodoAST labeled_statement_list, selection_statement_has_else, selection_statement, native_methods;
non terminal NodoAST bracket_list_value, native_functions, global_list, function_statement;
non terminal NodoAST parameter_list, selection_statement_has_more, parentheses_expression;
non terminal NodoAST compound_statement, parameter, declarator, s, boolean_value, expression_list;
non terminal NodoAST function_parameters, id;

precedence left CPAR;

precedence left QUESTION;
precedence left OR_OP;
precedence left AND_OP;
precedence right INVERT;
precedence left ASSIGN, EQ_OP, NE_OP;
precedence left GTHAN, LTHAN, GE_OP, LE_OP;

precedence left ADD,SUB;

precedence left MUL, DIV;
precedence left POT, MOD;

precedence right INC_OP, DEC_OP;
// precedence right SUB;

start with s;

s::= 
    global_list:l	
        {:	
            parser.root=l;	
        :}
    ;

global_list::=
    global_list:l function_statement:f
        {:
        	RESULT=transferirHijos(l,RESULT);
            RESULT=transferirHijos(f,RESULT);	
        :}
    | global_list:l statement:s
        {:
        	RESULT=transferirHijos(l,RESULT);
            RESULT=transferirHijos(s,RESULT);	
        :}
    | statement:s
        {:	
            RESULT = s;	
        :}
    | function_statement:f
        {:
            RESULT = f;
        :}
    ;

function_statement::=
    id:i ASSIGN function_parameters:v OCUR compound_statement:l
        {:	NodoAST funcion= new Instruccion();
            funcion.type(TYPE.FUNCTION);
            funcion.add(i);
            funcion.add(l);
            funcion.add(v);
            
            RESULT=new Instruccion();
            RESULT.add(funcion);
        :}
    ;

function_parameters::=
    OPAR parameter_list:v ASSIGN GTHAN
        {:
            RESULT = v;
        :}
    | FUNCTION OPAR parameter_list:v
        {:
            RESULT=v;
        :}
    ;

statement_list::=
    statement_list:l statement:s
        {:
        	RESULT=transferirHijos(l,RESULT);
            RESULT=transferirHijos(s,RESULT);	
        :}
    | statement:s
        {:	
            RESULT = s;	
        :}
    ;

statement::=
    declarator:d SCOLON
        {:
            RESULT = new Instruccion();
            RESULT.add(d);
        :}
    | declarator:d
        {:
            RESULT = new Instruccion();
            RESULT.add(d);
        :}
    | id_or_call:i SCOLON
        {:
            RESULT = new Instruccion();
            RESULT.add(i);
        :}
    | id_or_call:i
        {:
            RESULT = new Instruccion();
            RESULT.add(i);
        :}
    | native_methods:n
        {:
            RESULT = new Instruccion();
            RESULT.add(n);
        :}
	| selection_statement:s
		{: 
            RESULT = s; 					
        :}
	| iteration_statement:i
		{: 
            RESULT = i;
        :}
    | jump_statement:j SCOLON
        {:
            RESULT = j;
        :}
    | jump_statement:j
        {:
            RESULT = j;
        :}
    ;

declarator::=
    id:i ASSIGN expression:e
        {:  RESULT = new Instruccion();
            RESULT.type(TYPE.DECLARE);
            i.type(TYPE.STRING);
            RESULT.add(i);
            RESULT.add(e);
        :}
    | id:i bracket_list_value:v ASSIGN expression:e
        {:  RESULT = new Instruccion();
            RESULT.type(TYPE.DECLARE);
            i.type(TYPE.STRING);
            RESULT.add(i);
            RESULT.add(e);
            RESULT.add(v);
        :}
    ;

parameter::=
     parameter:l COMA id:i ASSIGN expression:e
        {:  RESULT=transferirHijos(l,RESULT);

            NodoAST defaul = new Instruccion();
            defaul.type(TYPE.DECLARE);
            defaul.add(i);
            defaul.add(e);

            RESULT.add(defaul);
        :}
    | parameter:l COMA id:i
        {:  RESULT=transferirHijos(l,RESULT);

            NodoAST param = new Instruccion();
            param.type(TYPE.DECLARE);
            param.add(i);
            RESULT.add(param);
        :}
    | COMA id:i ASSIGN expression:e
        {:  RESULT= new Instruccion();

            NodoAST param = new Instruccion();
            param.type(TYPE.DECLARE);
            param.add(i);
            param.add(e);
            RESULT.add(param);
        :}
    | COMA id:i
        {:  RESULT= new Instruccion();

            NodoAST param = new Instruccion();
            param.type(TYPE.DECLARE);
            param.add(i);
            RESULT.add(param);
        :}
    ;

id::=
    IDENTIFIER:i
        {: 
            RESULT = new Expresion();
            RESULT.type(TYPE.ID);
            RESULT.add(i);
    	:}
    ;

compound_statement::=
    statement_list:s CCUR
		{: 
            RESULT = s;					
        :}
	| CCUR
		{: 
            RESULT = new Instruccion();			
        :}

    ;

parameter_list::=  
	id:i parameter:l CPAR
        {:  RESULT=new Instruccion();

            NodoAST param = new Instruccion();
            param.type(TYPE.DECLARE);
            param.add(i);

            RESULT.add(param);
            RESULT = transferirHijos(l,RESULT);
        :}
    | id:i ASSIGN expression:e parameter:l CPAR
        {:  RESULT=new Instruccion();

            NodoAST defaul = new Instruccion();
            defaul.type(TYPE.DECLARE);
            defaul.add(i);
            defaul.add(e);

            RESULT.add(defaul);
            RESULT = transferirHijos(l,RESULT);
        
        :}
    | id:i CPAR
        {:  RESULT=new Instruccion();

            NodoAST param = new Instruccion();
            param.type(TYPE.DECLARE);
            param.add(i);

            RESULT.add(param);
        :}
    | CPAR
        {:
            RESULT = new Instruccion();
        :}
    ;

parentheses_expression::=
    expression_list:l CPAR
        {:
            RESULT = l;
        :}
    | CPAR
    ;

expression_list::=
    expression_list:l COMA expression:e
        {:  RESULT = transferirHijos(l,RESULT);
            RESULT.add(e);
        :}
    | expression:e
        {:  RESULT=new Instruccion();
            RESULT.add(e);
        :}
    ;

bracket_list_value::=
    bracket_list_value:l OBRA expression:e CBRA
        {:
            RESULT = transferirHijos(l, RESULT);
            RESULT.add(e);
        :}
    | OBRA expression:e CBRA
        {:
            RESULT = new Instruccion();
            RESULT.add(e);
        :}
    ;

native_methods::=
    PRINT OPAR expression:e CPAR SCOLON 
        {:	
            NodoAST imprimir = new Instruccion();
            imprimir.add(e);
            imprimir.type(TYPE.PRINT);
            RESULT = imprimir;	
        :}
    | PRINT OPAR expression:e CPAR
        {:	
            NodoAST imprimir = new Instruccion();
            imprimir.add(e);
            imprimir.type(TYPE.PRINT);
            RESULT = imprimir;	
        :}
    | error SCOLON
    ;
	
selection_statement::=
    SWITCH OPAR expression:e CPAR OCUR labeled_statement_list:l CCUR
        {:
        	NodoAST selecciona= new Instruccion();
            selecciona.type(TYPE.SWITCH);
            selecciona.add(e);
            selecciona=transferirHijos(l,selecciona);
            RESULT=new Instruccion();
            RESULT.add(selecciona);	
        :}
    | IF OPAR expression:e CPAR OCUR compound_statement:c selection_statement_has_more:v
        {:	
            NodoAST si = new Instruccion();
            si.type(TYPE.IF);
            si.add(e);
            si.add(c);
            if(v!=null)
                si = transferirHijos(v, si);
            RESULT = new Instruccion();
            RESULT.add(si);
        :}
    | IF OPAR expression:e CPAR OCUR compound_statement:c
        {:	
            NodoAST si = new Instruccion();
            si.type(TYPE.IF);
            si.add(e);
            si.add(c);
            RESULT = new Instruccion();
            RESULT.add(si);
        :}
    ;

selection_statement_has_more::= 
    selection_statement_has_more:l ELSE selection_statement_has_else:v 
        {:	
            RESULT = transferirHijos(l, RESULT);
			RESULT = transferirHijos(v, RESULT);	
        :}
    | ELSE selection_statement_has_else:v 
        {:	RESULT=v;	:}
    ;

selection_statement_has_else::= 
    IF OPAR expression:c CPAR OCUR compound_statement:l
        {:	
            RESULT=new Instruccion();
            NodoAST sinosi=new Instruccion();
            sinosi.type(TYPE.IF_ELSE);
            sinosi.add(c);
            sinosi.add(l);
            RESULT.add(sinosi);	 
        :}
    | OCUR compound_statement:l	
        {:	
            NodoAST sino = new Instruccion();
            sino.type(TYPE.ELSE);
            sino.add(l);
            RESULT= new Instruccion();
            RESULT.add(sino);	
        :}
    ;

labeled_statement_list::=
	labeled_statement_list:l labeled_statement:w
		{: 
            RESULT = transferirHijos(l, RESULT);
		    RESULT.add(w);
    	:}
	| labeled_statement:w
		{: 
            RESULT = new Instruccion();
		    RESULT.add(w);
		:}
	;

labeled_statement::= 
	CASE primary_expression:e COLON statement_list:s
		{: 
            RESULT = new Instruccion();
            RESULT.type(TYPE.CASE);
            RESULT.add(e);
            NodoAST list = new Instruccion();
            list = transferirHijos(s, null);
            RESULT.add(list);
		:}
	| DEFAULT COLON statement_list:s
		{: 
            RESULT = new Instruccion();
            RESULT.type(TYPE.DEFAULT);
            NodoAST list = transferirHijos(s, null);
            RESULT.add(list);
		:}
    ;

iteration_statement::= 
	WHILE OPAR expression:e CPAR OCUR compound_statement:s
		{: 
            NodoAST h = new Instruccion();
            h.type(TYPE.WHILE);
            h.add(e);
            h.add(s);
            RESULT = new Instruccion();
            RESULT.add(h);	
		:}
	| DO OCUR compound_statement:s WHILE OPAR bool_expression:e CPAR SCOLON
		{: 
            NodoAST D = new Instruccion();
            D.type(TYPE.DO);
            D.add(s);
            D.add(e);
            RESULT = new Instruccion();
            RESULT.add(D);
 		:}
    | DO OCUR compound_statement:s WHILE OPAR bool_expression:e CPAR
		{: 
            NodoAST D = new Instruccion();
            D.type(TYPE.DO);
            D.add(s);
            D.add(e);
            RESULT = new Instruccion();
            RESULT.add(D);
 		:}
    | FOR OPAR expression IN expression CPAR OCUR compound_statement
    ;

jump_statement::= 
	CONTINUE
		{: 
            NodoAST c = new Instruccion();
		    c.type(TYPE.CONTINUE);
            RESULT = new Instruccion();
            RESULT.add(c);
		:}
	| BREAK
		{: 
            NodoAST detener = new Instruccion();
            detener.type(TYPE.BREAK);
            RESULT=new Instruccion();
            RESULT.add(detener);
		:}
	| RETURN expression:e
		{: 
            NodoAST retornar = new Instruccion();
            retornar.type(TYPE.RETURN);
            retornar.add(e);
            RESULT = new Instruccion();
            RESULT.add(retornar) ;
		:}
    ;

primary_expression::= 
    TSTRING:s
		{: 
            RESULT = new Expresion();
            RESULT.add(s.replaceAll("\"",""));
            RESULT.type(TYPE.STRING);
        :}
	| NUM:n
		{: 
            RESULT = new Expresion();
            if(n.contains(".")){
                //DOUBLE
                RESULT.type(TYPE.FLOAT);
                RESULT.add(Double.valueOf(n));
            }else{
                //INT
                RESULT.type(TYPE.NUM);
                RESULT.add(Integer.valueOf(n));
            }							
        :}
	| NULL_VAL
		{: 
            RESULT = new Expresion();
		    RESULT.type(TYPE.NULL);
            RESULT.add("null");			
        :}
    | boolean_value:b
        {:
            RESULT=b;
        :}
    ;

expression::= 
    expression:e1 ADD expression:e2    
        {: 
            NodoAST ADD = new Instruccion();
            ADD.type(TYPE.ADD);
            ADD.add(e1);
            ADD.add(e2);
            RESULT = ADD; 
        :} 
	| expression:e1 SUB expression:e2    
        {: 
            NodoAST men = new Instruccion();
            men.type(TYPE.SUB);
            men.add(e1);
            men.add(e2);
            RESULT = men; 
        :} 
	| expression:e1 MUL expression:e2 
        {: 
            NodoAST MUL = new Instruccion();
            MUL.type(TYPE.MUL);
            MUL.add(e1);
            MUL.add(e2);
            RESULT = MUL; 
        :} 
	| expression:e1 MOD expression:e2 
        {: 
            NodoAST MUL = new Instruccion();
            MUL.type(TYPE.MOD);
            MUL.add(e1);
            MUL.add(e2);
            RESULT = MUL; 
        :} 
	| expression:e1 DIV expression:e2 
        {:	
            NodoAST div = new Instruccion();
            div.type(TYPE.DIV);
            div.add(e1);
            div.add(e2);
            RESULT = div; 
        :}
    | expression:e1 POT expression:e2
        {:	
            NodoAST pot = new Instruccion();
            pot.type(TYPE.POT);
            pot.add(e1);
            pot.add(e2);
            RESULT = pot; 
        :}
	| OPAR expression:e CPAR
		{: 
            RESULT=e;	
        :}		 			 
	| primary_expression:n  	 
        {:	
            RESULT=n; 
        :}				
	| INVERT expression:e1
        {:	
            NodoAST INVERT=new Instruccion();
            INVERT.add(e1);
            INVERT.type(TYPE.INVERT);
            RESULT=INVERT;	
        :}
	| SUB expression:e1
        {:	
            NodoAST menosUno = new Expresion();
            menosUno.type(TYPE.NUM);
            menosUno.add(-1);
            NodoAST INVERT=new Instruccion();
            INVERT.add(e1);
            INVERT.add(menosUno);
            INVERT.type(TYPE.MUL);
            RESULT=INVERT;	
        :}
    | ternary_expression:t
        {:
            RESULT = t;
        :}
    | id_or_call:i
        {:
            RESULT = i;
        :}
    | bool_expression:b
        {: 
            RESULT=b;
        :}
    ;

id_or_call::=
    id:i OPAR parentheses_expression:m
        {:  NodoAST metodo=new Instruccion();
            metodo.type(TYPE.CALL);
            metodo.add(i);
            metodo=transferirHijos(m,metodo);
            RESULT= metodo;
        :}
    | id:i INC_OP
        {:    
            NodoAST id = new Expresion();
            id.type(TYPE.ID);
            id.add(i);

            NodoAST buscarID= new Instruccion();
            buscarID.add(id);
            buscarID.type(TYPE.EXISTS);
            
            NodoAST aumento=new Instruccion();
            aumento.type(TYPE.INC_OP);
            aumento.add(buscarID);
            
            RESULT= aumento;
        :}
    | id:i DEC_OP
        {:
            NodoAST id = new Expresion();
            id.type(TYPE.ID);
            id.add(i);

            NodoAST buscarID= new Instruccion();
            buscarID.add(id);
            buscarID.type(TYPE.EXISTS);
            
            NodoAST aumento=new Instruccion();
            aumento.type(TYPE.DEC_OP);
            aumento.add(buscarID);
            
            RESULT=aumento;
        :}
    | id:i bracket_list_value:v
        {:  RESULT = new Instruccion();
            RESULT.add(i);
            RESULT.add(v);
        :}
    | id:i
        {:
            RESULT = i;
        :}
    ;
bool_expression::= 
    expression:e1 EQ_OP expression:e2
        {:	
            NodoAST igualdad = new Instruccion();
            igualdad.type(TYPE.EQUAL);
            igualdad.add(e1);
            igualdad.add(e2);
            RESULT = igualdad; 
        :}
    | expression:e1 NE_OP expression:e2
        {:	
            NodoAST distinto = new Instruccion();
            distinto.type(TYPE.NOEQUAL);
            distinto.add(e1);
            distinto.add(e2);
            RESULT = distinto; 
        :}
    | expression:e1 AND_OP expression:e2
        {:	
            NodoAST AND_OP = new Instruccion();
            AND_OP.type(TYPE.AND);
            AND_OP.add(e1);
            AND_OP.add(e2);
            RESULT = AND_OP; 
        :}
    | expression:e1 OR_OP expression:e2
        {:	
            NodoAST OR_OP = new Instruccion();
            OR_OP.type(TYPE.OR);
            OR_OP.add(e1);
            OR_OP.add(e2);
            RESULT = OR_OP; 
        :}
    | expression:e1 LTHAN expression:e2
        {:	
            NodoAST LTHAN = new Instruccion();
            LTHAN.type(TYPE.LTHAN);
            LTHAN.add(e1);
            LTHAN.add(e2);
            RESULT = LTHAN; 
        :}
    | expression:e1 GTHAN expression:e2
        {:	
            NodoAST GTHAN = new Instruccion();
            GTHAN.type(TYPE.GTHAN);
            GTHAN.add(e1);
            GTHAN.add(e2);
            RESULT = GTHAN; 
        :}
    | expression:e1 LE_OP expression:e2
        {:	
            NodoAST menorI = new Instruccion();
            menorI.type(TYPE.LE_OP);
            menorI.add(e1);
            menorI.add(e2);
            RESULT = menorI; 
        :}
    | expression:e1 GE_OP expression:e2
        {:	
            NodoAST mayorI = new Instruccion();
            mayorI.type(TYPE.GE_OP);
            mayorI.add(e1);
            mayorI.add(e2);
            RESULT = mayorI; 
        :}
    
    ;

boolean_value::=
    TRUE_VAL
		{: 
            RESULT = new Expresion();
            RESULT.type(TYPE.BOOLEAN);
            RESULT.add(true);
    	:}
	| FALSE_VAL
		{: 
            RESULT = new Expresion();
            RESULT.type(TYPE.BOOLEAN);
            RESULT.add(false);
		:}
	;

ternary_expression::=
    expression:e1 QUESTION expression:e2 COLON expression:e3
        {:	
            NodoAST ternario = new Instruccion();
            ternario.type(TYPE.TERNARY);
            ternario.add(e1);
            ternario.add(e2);
            ternario.add(e3);
            RESULT = ternario; 
        :}
    ;